URL: https://segment.com/docs/guides/intro-impl/

Segment for Developers | Segment Documentation
Skip to main content
Home
Getting Started
What is Segment?
How Segment Works
Getting Started Guide
A Basic Segment Installation
Planning a Full Installation
A Full Segment Installation
Sending Data to Destinations
Testing and Debugging
What's Next
Use Cases
Use Cases Overview
Choosing a Use Case
Use Cases Setup
Use Cases Reference
Guides
An Introduction to Segment
For Developers
For Data Users
For Workspace Admins
Filtering your Segment Data
Handling Duplicate Data
Internet Bots
Segment vs. Tag Managers
Replay
Regional Segment
Audiences and Journeys
How-to Guides
How-to Guides Index
Automating Multi-Channel Re-Engagement Campaigns
Collecting Data on the Client or Server
Collecting Pageviews on the Server Side
Creating a Push Notification
Tracking Customers Across Channels and Devices
Setting up a Dynamic Coupon Program to Reward Loyal Customers
Forecasting LTV with SQL and Excel for E-Commerce
Importing Historical Data
Joining User Profiles
Measuring Your Advertising Funnel
Measuring the ROI of Your Marketing Campaigns
Migrating Code From Other Analytics Tools
Segment's Role in Attribution
Setting Up Event-Triggered Notifications or Alerts
Usage and Billing
Account Management
Billing and Account FAQs
MTUs, Throughput and Billing
Discounts or Coupons
Connections
Overview
The Segment Spec
Spec Overview
Spec: Page
Spec: Screen
Spec: Track
Spec: Group
Spec: Identify
Spec: Alias
Spec: AI Copilot
Spec: Common Fields
Native Mobile Spec
What is the native mobile spec?
Packaging SDKs for Mobile Destinations
Spec: Semantic Events
Spec: B2B SaaS
Spec: Ecommerce Events
Ecommerce Tracking Plans
Video Spec
Best Practices for Identifying Users
Best Practices for Event Calls
Sources
Sources Overview
Sources Catalog
Cloud Sources
Source Debugger
Segment-Managed Custom Domain
Self-Managed Custom Proxy
Visual Tagger
Schema
Schema Controls
Using Schema Controls
Schema Unique Limits
Destinations
Destinations Overview
Destination Actions
Add a Destination
Destinations Catalog
Destination Filters
Reverse ETL
Reverse ETL Overview
Set Up Reverse ETL
Manage Reverse ETL Syncs
Reverse ETL System
Reverse ETL Destination Catalog
Reverse ETL Source Setup Guides
Azure Reverse ETL Setup
BigQuery Reverse ETL Setup
Databricks Reverse ETL Setup
Postgres Reverse ETL Setup
Redshift Reverse ETL Setup
Snowflake Reverse ETL Setup
Functions
Functions Overview
Source Functions
Destination Functions
Destination Insert Functions
Functions Copilot
Functions Copilot Nutrition Facts Label
Functions Environment
Functions Usage Limits
Functions for AWS APIs
Storage Destinations
Storage Destinations Overview
Storage Destinations Catalog
Segment Data Lakes
Data Lakes Overview
Set Up Data Lakes
Sync Reports and Error Reporting
AWS Lake Formation
Data Lakes Sync History and Health
Data Lakes vs. Warehouses
Data Warehouses
Warehouse Overview
Warehouse Schemas
Warehouse Syncs
Warehouse Health Dashboards
Choosing a Warehouse
Warehouse FAQs
Adding Warehouse Users
Warehouse Errors
Redshift Cluster and Redshift Connector Limitations
Speeding Up Redshift Queries
Useful SQL Queries for Redshift
Regional Segment
Event Tester
Data Export Options
Using Schema Controls
Event Delivery
Delivery Overview
Connections Alerting
Locate Your Write Key
Integration Error Codes
Rate Limits
OAuth 2.0
AWS PrivateLink Integration
Unify
Unify Overview
Unify Onboarding
Identity Resolution
Overview
Onboarding
Space Setup
Use Cases
External IDs
Settings
E-Commerce Example
Profiles Sync
Profiles Sync Overview
Profiles Sync Setup
Setup
Databricks for Profiles Sync
Sample Queries
Tables & Materialized Views
Data Graph
Data Graph
Setup Guides
BigQuery Data Graph Setup
Databricks Data Graph Setup
Redshift Data Graph Setup
Snowflake Data Graph Setup
Linked Events
Linked Events Overview
Linked Events Limits
Traits
Predictions
Predictions
Using Predictions
Suggested Predictive Audiences
Predictions Nutrition Facts Label
Computed Traits
Custom Traits
SQL Traits
Recommended Items
Profile API
Profile Debugger
Profiles Insights
CSV Upload
Unify and GDPR
Unify FAQs
Unify Limits
Engage
Introduction
Foundations Onboarding
Premier Onboarding
Use Cases
User Subscriptions
User Subscriptions
Set User Subscriptions
Subscription States
Subscription Groups
Subscriptions with SQL Traits
Update Subscriptions with a CSV
Profiles
Use Profiles and Traits with a CSV
Audiences
Audiences Overview
Linked Audiences
Linked Audiences Overview
Linked Audiences Limits
Account-level Audiences
Generative Audiences
Generative Audiences Nutrition Facts Label
Product Based Audiences
Product Based Audiences Nutrition Facts Label
Organize Audiences
Send Audiences to Destinations
Journeys
Journeys Overview
Build a Journey
Journey Step Types
Journey Edits and Versioning
Send Data to Destinations
Journeys Analytics
Event-Triggered Journeys
Overview
Event-Triggered Journeys Steps
Journey Context
Journeys Best Practices and FAQ
Example Journeys Use Cases
Understand Journeys Logic
Journeys Glossary
Content
Email Template
Drag and Drop Editor
HTML Editor
SMS Template
WhatsApp Template
Mobile Push Template
Organizing Your Templates
Campaigns
Campaigns Overview
Email Campaigns
SMS Campaigns
Broadcasts
WhatsApp Campaigns
Mobile Push
Mobile Push Onboarding
Mobile Push Campaigns
Trait Activation
Trait Activation Overview
Trait Enrichment
ID Sync
Analytics Overview
Engage Settings
Engage Default Limits
Engage and Warehouses
Using Engage Data
Engage FAQs
Privacy
Privacy Overview
Privacy Portal
Detect PII
Data Controls and Alerts
GDPR
Complying With GDPR
User Deletion and Suppression
Consent Management
Consent Management Overview
Consent in Segment Connections
Configure Consent Management
Consent in Unify
Consent in Reverse ETL
Consent FAQs
Account & Data Deletion
HIPAA Eligible Segment
Privacy FAQs
Protocols
Protocols Overview
Create a Tracking Plan
Data Collection Best Practices
The Tracking Plan
Tracking Plan Libraries
Validate With Violations
Connect Sources to Your Tracking Plan
Review and Resolve Event Violations
Forward Violations
Enforce With Data Controls
Customize Your Schema Controls
Forward Blocked Events
Transform to Fix Bad Data
Protocols Extensions
Protocols APIs
Typewriter
Anomaly Detection
Schema Controls
Protocols FAQs
Segment App
Segment Web App
Workspace Home
Access Management
Identity & Access Management Overview
Concepts
Roles
Manage Workspace Access
Label-Based Access Control
Audit Trail
Single Sign On
System for Cross-domain Identity Management (SCIM) Configuration Guide
Multi-Factor Authentication (MFA)
Extensions
Extensions Overview
dbt
Git
Picking a Secure Password
Prod and Testing Environments in Segment
Verifying Your Email Address
Support Access
API
Public API
Public API
Destination Filter Query Language
Segment Query Language
Config API
Config API overview
API design
Authentication
Destination Filter Query Language
Partners
Glossary
Help
Product Updates
Back to Segment.com
Log in
Sign Up
Home
Getting Started
What is Segment?
How Segment Works
Getting Started Guide
A Basic Segment Installation
Planning a Full Installation
A Full Segment Installation
Sending Data to Destinations
Testing and Debugging
What's Next
Use Cases
Use Cases Overview
Choosing a Use Case
Use Cases Setup
Use Cases Reference
Guides
An Introduction to Segment
For Developers
For Data Users
For Workspace Admins
Filtering your Segment Data
Handling Duplicate Data
Internet Bots
Segment vs. Tag Managers
Replay
Regional Segment
Audiences and Journeys
How-to Guides
How-to Guides Index
Automating Multi-Channel Re-Engagement Campaigns
Collecting Data on the Client or Server
Collecting Pageviews on the Server Side
Creating a Push Notification
Tracking Customers Across Channels and Devices
Setting up a Dynamic Coupon Program to Reward Loyal Customers
Forecasting LTV with SQL and Excel for E-Commerce
Importing Historical Data
Joining User Profiles
Measuring Your Advertising Funnel
Measuring the ROI of Your Marketing Campaigns
Migrating Code From Other Analytics Tools
Segment's Role in Attribution
Setting Up Event-Triggered Notifications or Alerts
Usage and Billing
Account Management
Billing and Account FAQs
MTUs, Throughput and Billing
Discounts or Coupons
Connections
Overview
The Segment Spec
Spec Overview
Spec: Page
Spec: Screen
Spec: Track
Spec: Group
Spec: Identify
Spec: Alias
Spec: AI Copilot
Spec: Common Fields
Native Mobile Spec
What is the native mobile spec?
Packaging SDKs for Mobile Destinations
Spec: Semantic Events
Spec: B2B SaaS
Spec: Ecommerce Events
Ecommerce Tracking Plans
Video Spec
Best Practices for Identifying Users
Best Practices for Event Calls
Sources
Sources Overview
Sources Catalog
Cloud Sources
Source Debugger
Segment-Managed Custom Domain
Self-Managed Custom Proxy
Visual Tagger
Schema
Schema Controls
Using Schema Controls
Schema Unique Limits
Destinations
Destinations Overview
Destination Actions
Add a Destination
Destinations Catalog
Destination Filters
Reverse ETL
Reverse ETL Overview
Set Up Reverse ETL
Manage Reverse ETL Syncs
Reverse ETL System
Reverse ETL Destination Catalog
Reverse ETL Source Setup Guides
Azure Reverse ETL Setup
BigQuery Reverse ETL Setup
Databricks Reverse ETL Setup
Postgres Reverse ETL Setup
Redshift Reverse ETL Setup
Snowflake Reverse ETL Setup
Functions
Functions Overview
Source Functions
Destination Functions
Destination Insert Functions
Functions Copilot
Functions Copilot Nutrition Facts Label
Functions Environment
Functions Usage Limits
Functions for AWS APIs
Storage Destinations
Storage Destinations Overview
Storage Destinations Catalog
Segment Data Lakes
Data Lakes Overview
Set Up Data Lakes
Sync Reports and Error Reporting
AWS Lake Formation
Data Lakes Sync History and Health
Data Lakes vs. Warehouses
Data Warehouses
Warehouse Overview
Warehouse Schemas
Warehouse Syncs
Warehouse Health Dashboards
Choosing a Warehouse
Warehouse FAQs
Adding Warehouse Users
Warehouse Errors
Redshift Cluster and Redshift Connector Limitations
Speeding Up Redshift Queries
Useful SQL Queries for Redshift
Regional Segment
Event Tester
Data Export Options
Using Schema Controls
Event Delivery
Delivery Overview
Connections Alerting
Locate Your Write Key
Integration Error Codes
Rate Limits
OAuth 2.0
AWS PrivateLink Integration
Unify
Unify Overview
Unify Onboarding
Identity Resolution
Overview
Onboarding
Space Setup
Use Cases
External IDs
Settings
E-Commerce Example
Profiles Sync
Profiles Sync Overview
Profiles Sync Setup
Setup
Databricks for Profiles Sync
Sample Queries
Tables & Materialized Views
Data Graph
Data Graph
Setup Guides
BigQuery Data Graph Setup
Databricks Data Graph Setup
Redshift Data Graph Setup
Snowflake Data Graph Setup
Linked Events
Linked Events Overview
Linked Events Limits
Traits
Predictions
Predictions
Using Predictions
Suggested Predictive Audiences
Predictions Nutrition Facts Label
Computed Traits
Custom Traits
SQL Traits
Recommended Items
Profile API
Profile Debugger
Profiles Insights
CSV Upload
Unify and GDPR
Unify FAQs
Unify Limits
Engage
Introduction
Foundations Onboarding
Premier Onboarding
Use Cases
User Subscriptions
User Subscriptions
Set User Subscriptions
Subscription States
Subscription Groups
Subscriptions with SQL Traits
Update Subscriptions with a CSV
Profiles
Use Profiles and Traits with a CSV
Audiences
Audiences Overview
Linked Audiences
Linked Audiences Overview
Linked Audiences Limits
Account-level Audiences
Generative Audiences
Generative Audiences Nutrition Facts Label
Product Based Audiences
Product Based Audiences Nutrition Facts Label
Organize Audiences
Send Audiences to Destinations
Journeys
Journeys Overview
Build a Journey
Journey Step Types
Journey Edits and Versioning
Send Data to Destinations
Journeys Analytics
Event-Triggered Journeys
Overview
Event-Triggered Journeys Steps
Journey Context
Journeys Best Practices and FAQ
Example Journeys Use Cases
Understand Journeys Logic
Journeys Glossary
Content
Email Template
Drag and Drop Editor
HTML Editor
SMS Template
WhatsApp Template
Mobile Push Template
Organizing Your Templates
Campaigns
Campaigns Overview
Email Campaigns
SMS Campaigns
Broadcasts
WhatsApp Campaigns
Mobile Push
Mobile Push Onboarding
Mobile Push Campaigns
Trait Activation
Trait Activation Overview
Trait Enrichment
ID Sync
Analytics Overview
Engage Settings
Engage Default Limits
Engage and Warehouses
Using Engage Data
Engage FAQs
Privacy
Privacy Overview
Privacy Portal
Detect PII
Data Controls and Alerts
GDPR
Complying With GDPR
User Deletion and Suppression
Consent Management
Consent Management Overview
Consent in Segment Connections
Configure Consent Management
Consent in Unify
Consent in Reverse ETL
Consent FAQs
Account & Data Deletion
HIPAA Eligible Segment
Privacy FAQs
Protocols
Protocols Overview
Create a Tracking Plan
Data Collection Best Practices
The Tracking Plan
Tracking Plan Libraries
Validate With Violations
Connect Sources to Your Tracking Plan
Review and Resolve Event Violations
Forward Violations
Enforce With Data Controls
Customize Your Schema Controls
Forward Blocked Events
Transform to Fix Bad Data
Protocols Extensions
Protocols APIs
Typewriter
Anomaly Detection
Schema Controls
Protocols FAQs
Segment App
Segment Web App
Workspace Home
Access Management
Identity & Access Management Overview
Concepts
Roles
Manage Workspace Access
Label-Based Access Control
Audit Trail
Single Sign On
System for Cross-domain Identity Management (SCIM) Configuration Guide
Multi-Factor Authentication (MFA)
Extensions
Extensions Overview
dbt
Git
Picking a Secure Password
Prod and Testing Environments in Segment
Verifying Your Email Address
Support Access
API
Public API
Public API
Destination Filter Query Language
Segment Query Language
Config API
Config API overview
API design
Authentication
Destination Filter Query Language
Partners
Glossary
Config API
Config API overview
API design
Authentication
Destination Filter Query Language
Reference
Creating a Javascript web source and Google Analytics destination
Help
Home
/
Guides
/
Segment for Developers
Segment for Developers
On this page
What does Segment do?
Types of Segment messages
Anatomy of a Segment message
Message schemas, Blocks, and Specs
Sources and Destinations
Connection modes
Planning your Segment implementation
How do I test if it’s working?
How do I filter my data?
Troubleshooting
Segment Terraform Provider
This guide explains all you need to know to get started with your Segment implementation, and directs you to more resources depending on your specific needs.
If you haven’t already, you should read the detailed explanation of Segment on the previous page!
Segment University: Segment in Action
See a quick example of Segment working on an ecommerce website. (Must be logged in to access.)
What does Segment do?
Segment sends messages about activities in your mobile apps, websites or servers, receives those messages, and translates and forwards the message content to Destination tools. It also can send the contents of those messages to a bulk storage destination for archiving. In more complicated implementations, Segment can serve as a wrapper to trigger messages directly to other APIs, and can inspect, correct, classify and block the message contents.
Types of Segment messages
Segment’s libraries generate and send messages to our tracking API in JSON format, and provide a standard structure for the basic API calls. We also provide recommended JSON structure (also known as a schema, or ‘Spec’) that helps keep the most important parts of your data consistent, while allowing great flexibility in what other information you collect and where.
There are six calls in the basic tracking API, which answer specific questions:
Identify: Who is the user?
Track: What are they doing?
Page: What web page are they on?
Screen: What app screen are they on?
Group: What account or organization are they part of?
Alias: What was their past identity?
Among these calls, you can think of Identify, Group, and Alias as similar types of calls, all to do with updating our understanding of the user who is triggering Segment messages. You can think of these calls as adding information to, or updating an object record in a database. Objects are described using “traits”, which you can collect as part of your calls.
The other three, Track, Page, and Screen, can be considered as increasingly specific types of events. Events can occur multiple times, but generate separate records which append to a list, instead of being updated over time.
A Track call is the most basic type of call, and can represent any type of event. Page and Screen are similar and are triggered by a user viewing a page or screen, however Page calls can come from both web and mobile-web views, while Screen calls only occur on mobile devices. Because of the difference in platform, the context information collected is very different between the two types of calls.
Tip! Segment recommends that you always use the Page and Screen calls when recording a page-view, rather than creating a “Page Viewed” event, because the Page/Screen calls automatically collect much better context information.
Anatomy of a Segment message
The most basic Segment message requires only a userID or anonymousID; all other fields are optional to allow for maximum flexibility. However, a normal Segment message has three main parts: the common fields, the “context” object, and the properties (if it’s an event) or traits (if it’s an object).
The common fields include information specific to how the call was generated, like the timestamp and library name and version. The fields in the context object are usually generated by the library, and include information about the environment in which the call was generated: page path, user agent, OS, locale settings, etc. The properties and traits are optional and are where you customize the information you want to collect for your implementation.
Another common part of a Segment message is the integrations object, which you can use to explicitly filter which destinations the call is forwarded to. However this object is optional, and is often omitted in favor of non-code based filtering options.
Message schemas, Blocks, and Specs
The Segment “Specs” provide recommended message schemas - the information we recommend that you collect - for each type of call. These are recommendations not requirements, but if you follow these schema guidelines the Segment servers can more easily identify parts of your messages, and translate them to downstream tools.
In addition to the recommended message schemas, Segment also provides “blocks”: recommendations on what information to collect and how to format it, for different industries and use cases. These are recommendations only, but by collecting all of the information in these blocks, you can ensure that common tools used in that use-case have the information they need to function.
A third section of the Spec is the “industry specs” which provide recommendations that include an explicit translation or mapping in the Segment servers, to best power the downstream Destinations commonly used in these industries.
Sources and Destinations
When you start out, you create a Workspace, which serves as a container for all of your Sources and Destinations.
Segment has Sources and Destinations. Sources send data into Segment, while Destinations receive data from Segment.
Segment has five types of sources: Web (Analytics.js), Mobile, Server, and Cloud App, plus a fifth type: User-created Source Functions. Web, Mobile, and Server sources send first-party data from your digital properties. Cloud-app sources send data about your users from your connected web apps, for example a ticketing system such as Zendesk, a payments system such as Stripe, or a marketing tool like Braze.
Connection modes
Segment has several types of sources, and many destinations can accept data from all of them. However, some are only compatible with specific source types (for example, web only, or server only). To find out which source types a specific destination can accept data from, check the documentation for that destination for a “Supported Sources and Connection Modes” section.
Segment’s web source (Analytics.js), and native client-side libraries (iOS, Android, React-native) allow you to choose how you send data to Segment from your website or app. There are two ways to send data:
Cloud-mode: The sources send data directly to the Segment servers, which then translate it for each connected downstream destination, and send it on. Translation is done on the Segment servers, keeping your page size, method count, and load time small.
Healthcare and Life Sciences (HLS) customers can encrypt data flowing into their destinations
HLS customers with a HIPAA eligible workspace can encrypt data in fields marked as Yellow in the Privacy Portal before they flow into an event stream, cloud-mode destination.
To learn more about data encryption, see the HIPAA Eligible Segment documentation
Device-mode: You include additional code on your website or mobile app which allows Segment to use the data you collect on the device to make calls directly to the destination tool’s API, without sending it to the Segment servers first. (You still send your data to the Segment servers, but this occurs asynchronously.) This is also called wrapping or bundling, and it might be required when the source has to be loaded on the page to work, or loaded directly on the device to function correctly. When you use Analytics.js, you can change the device-mode destinations that a specific source sends from within the Segment web app, without touching any code.
If you use Server source libraries, they only send data directly to Segment in Cloud-mode. Server library implementations operate in the server backend, and can't load additional destination SDKs.
To learn more about connection modes and when you should use each, see the details in the Destinations docs.
Planning your Segment implementation
The journey of a thousand miles begins, ideally, with a plan. Regardless of if you’re a new company just implementing analytics for the first time, or a multi–national corporation modernizing your analytics stack, it’s a great idea to start with a Tracking Plan. For new implementations, this can be as simple as a document where you write down these four things for each item you track:
What am I tracking? (What is the event name or type?)
Why am I tracking it? (What questions does this data answer?)
For whom am I tracking it? (Who owns this question, tool, or business area?)
Where (which destination tools) do I want to send this data to?
If you’re a large or long-established organization and you’re replacing existing tools, you’ll want to spend more time on this to maintain analytic parity and continuity of tooling. We highly recommend reading up on tracking plans and schemas for Protocols, our tool for managing and sharing tracking plans and enforcing schemas.
Regardless of your organization’s size or age, you’ll want to take an inventory of the destination tools you’ll be using with Segment, and make a list of the connection modes each one accepts. This makes it easier to check off when you’ve implemented each one, so you’re not missing anything.
How do I test if it’s working?
There are several ways to check if your data is flowing. One is the Debugger tab in each Source in the Segment web app, where you can see data coming from a source into Segment. Another is the Event Delivery tool which shows which data is arriving at specific destinations.
For monitoring purposes, you’ll also see alerts in the Workspace Health tool if your sources or destinations produce repeated errors.
How do I filter my data?
There are several different ways to ensure that you can collect your data once, but filter it out of specific destinations. See Filtering Data for a list of the available methods and descriptions.
Troubleshooting
If you’re seeing errors thrown by your destinations, you might have an implementation issue. See the Integration Error Codes list or contact our Success engineering team for help.
Have suggestions for things to add to this guide? Drop us a line.
Segment Terraform Provider
Segment has a Terraform provider, powered by the Public API, that you can use to manage Segment resources, automate cloud deployments, and change control. Take a look at the Segment provider documentation on Terraform to see what’s supported.
This page was last modified: 09 Apr 2024
Need support?
Questions? Problems? Need more info? Contact Segment Support for assistance!
Visit our Support page
Help improve these docs!
Edit this page
Request docs change
Was this page helpful?
Yes
No
Thanks for your feedback!
Can we improve this doc? Send us feedback!
Get started with Segment
Segment is the easiest way to integrate your websites & mobile apps data to over 300 analytics and growth tools.
Request Demo
or
Create free account
Edit this page
Request docs change
On this page
What does Segment do?
Types of Segment messages
Anatomy of a Segment message
Message schemas, Blocks, and Specs
Sources and Destinations
Connection modes
Planning your Segment implementation
How do I test if it’s working?
How do I filter my data?
Troubleshooting
Segment Terraform Provider
Was this page helpful?
Yes
No
Thanks for your feedback!
Can we improve this doc? Send us feedback!
Product
Connections
Protocols
Twilio Engage
Integrations Catalog
Pricing
Security
GDPR
For Developers
Documentation
Segment API
Build on Segment
Open Source
Engineering Team
Company
Careers
Blog
Press
FTFY Podcast
Events
Support
Help Center
Contact us
Resources
Recipes
Security Bulletins
Become a Partner
© 2025 Segment.io, Inc.
Privacy
Terms
Website Data Collection Preferences
Send
Send
Send